(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('underscore'), require('@angular/core')) :
    typeof define === 'function' && define.amd ? define(['exports', 'underscore', '@angular/core'], factory) :
    (factory((global.ng = global.ng || {}, global.ng.meteor = global.ng.meteor || {}),global.underscore,global.ng.core));
}(this, (function (exports,_,_angular_core) { 'use strict';

var subscribeEvents = ['onReady', 'onError', 'onStop'];
function isMeteorCallbacks(callbacks) {
    return _.isFunction(callbacks) || isCallbacksObject(callbacks);
}
// Checks if callbacks of {@link CallbacksObject} type.
function isCallbacksObject(callbacks) {
    return callbacks && subscribeEvents.some(function (event) {
        return _.isFunction(callbacks[event]);
    });
}

var g = typeof global === 'object' ? global :
    typeof window === 'object' ? window :
        typeof self === 'object' ? self : undefined;
var gZone = g.Zone.current;
var check = Package['check'].check;
/* tslint:disable */

function debounce(func, wait, onInit) {
    var timeout, result, data;
    var later = function (context, args) {
        timeout = null;
        result = func.apply(context, args.concat([data]));
    };
    var debounced = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        if (!timeout) {
            data = onInit && onInit();
        }
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = _.delay(later, wait, this, args);
        return result;
    };
    return debounced;
}

function noop() { }
function isListLikeIterable(obj) {
    if (!isJsObject(obj))
        return false;
    return isArray(obj) ||
        (!(obj instanceof Map) &&
            getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
}
function isArray(obj) {
    return Array.isArray(obj);
}
function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
function isBlank(obj) {
    return obj === undefined || obj === null;
}
function isJsObject(o) {
    return o !== null && (typeof o === 'function' || typeof o === 'object');
}
var _symbolIterator = null;
function getSymbolIterator() {
    if (isBlank(_symbolIterator)) {
        if (isPresent(g.Symbol) && isPresent(Symbol.iterator)) {
            _symbolIterator = Symbol.iterator;
        }
        else {
            // es6-shim specific logic
            var keys = Object.getOwnPropertyNames(Map.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (key !== 'entries' && key !== 'size' &&
                    Map.prototype[key] === Map.prototype['entries']) {
                    _symbolIterator = key;
                }
            }
        }
    }
    return _symbolIterator;
}

var ZoneRunScheduler = (function () {
    function ZoneRunScheduler() {
        this._zoneTasks = new Map();
        this._onRunCbs = new Map();
    }
    ZoneRunScheduler.prototype.zoneRun = function (zone) {
        var _this = this;
        return function () {
            zone.run(noop);
            _this._runAfterRunCbs(zone);
            _this._zoneTasks.delete(zone);
        };
    };
    ZoneRunScheduler.prototype.runZones = function () {
        this._zoneTasks.forEach(function (task, zone) {
            task.invoke();
        });
    };
    ZoneRunScheduler.prototype._runAfterRunCbs = function (zone) {
        if (this._onRunCbs.has(zone)) {
            var cbs = this._onRunCbs.get(zone);
            while (cbs.length !== 0) {
                (cbs.pop())();
            }
            this._onRunCbs.delete(zone);
        }
    };
    ZoneRunScheduler.prototype.scheduleRun = function (zone) {
        if (zone === gZone) {
            return;
        }
        var runTask = this._zoneTasks.get(zone);
        if (runTask) {
            runTask.cancelFn(runTask);
            this._zoneTasks.delete(zone);
        }
        runTask = gZone.scheduleMacroTask('runZones', this.zoneRun(zone), { isPeriodic: true }, function (task) {
            task._tHandler = setTimeout(task.invoke);
        }, function (task) {
            clearTimeout(task._tHandler);
        });
        this._zoneTasks.set(zone, runTask);
    };
    ZoneRunScheduler.prototype.onAfterRun = function (zone, cb) {
        check(cb, Function);
        if (!this._zoneTasks.has(zone)) {
            cb();
            return;
        }
        var cbs = this._onRunCbs.get(zone);
        if (!cbs) {
            cbs = [];
            this._onRunCbs.set(zone, cbs);
        }
        cbs.push(cb);
    };
    return ZoneRunScheduler;
}());
var zoneRunScheduler = new ZoneRunScheduler();
function wrapFuncInZone(zone, method, context) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        gZone.run(function () {
            method.apply(context, args);
        });
        zoneRunScheduler.scheduleRun(zone);
    };
}
function wrapCallbackInZone(zone, callback, context) {
    if (_.isFunction(callback)) {
        return wrapFuncInZone(zone, callback, context);
    }
    for (var _i = 0, _a = _.functions(callback); _i < _a.length; _i++) {
        var fn = _a[_i];
        callback[fn] = wrapFuncInZone(zone, callback[fn], context);
    }
    return callback;
}
function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
}

var CursorHandle = (function () {
    function CursorHandle(hCurObserver, hAutoNotify) {
        check(hAutoNotify, Match.Optional(Tracker.Computation));
        check(hCurObserver, Match.Where(function (observer) {
            return !!observer.stop;
        }));
        this._hAutoNotify = hAutoNotify;
        this._hCurObserver = hCurObserver;
    }
    CursorHandle.prototype.stop = function () {
        if (this._hAutoNotify) {
            this._hAutoNotify.stop();
        }
        this._hCurObserver.stop();
    };
    return CursorHandle;
}());

var AddChange = (function () {
    function AddChange(index, item) {
        this.index = index;
        this.item = item;
    }
    return AddChange;
}());
var UpdateChange = (function () {
    function UpdateChange(index, item) {
        this.index = index;
        this.item = item;
    }
    return UpdateChange;
}());
var MoveChange = (function () {
    function MoveChange(fromIndex, toIndex) {
        this.fromIndex = fromIndex;
        this.toIndex = toIndex;
    }
    return MoveChange;
}());
var RemoveChange = (function () {
    function RemoveChange(index) {
        this.index = index;
    }
    return RemoveChange;
}());
/**
 * Class that does a background work of observing
 * Mongo collection changes (through a cursor)
 * and notifying subscribers about them.
 */
var MongoCursorObserver = (function (_super) {
    __extends(MongoCursorObserver, _super);
    function MongoCursorObserver(cursor, _debounceMs) {
        if (_debounceMs === void 0) { _debounceMs = 50; }
        _super.call(this);
        this._debounceMs = _debounceMs;
        this._lastChanges = [];
        this._ngZone = g.Zone.current;
        this._isSubscribed = false;
        check(cursor, Match.Where(MongoCursorObserver.isCursor));
        this._cursor = cursor;
    }
    MongoCursorObserver.isCursor = function (cursor) {
        return cursor && !!cursor.observe;
    };
    MongoCursorObserver.prototype.subscribe = function (events) {
        var sub = _super.prototype.subscribe.call(this, events);
        // Start processing of the cursor lazily.
        if (!this._isSubscribed) {
            this._isSubscribed = true;
            this._hCursor = this._processCursor(this._cursor);
        }
        return sub;
    };
    Object.defineProperty(MongoCursorObserver.prototype, "lastChanges", {
        get: function () {
            return this._lastChanges;
        },
        enumerable: true,
        configurable: true
    });
    MongoCursorObserver.prototype.destroy = function () {
        if (this._hCursor) {
            this._hCursor.stop();
        }
        this._hCursor = null;
    };
    MongoCursorObserver.prototype._processCursor = function (cursor) {
        // On the server side fetch data, don't observe.
        if (Meteor.isServer) {
            var changes = [];
            var index = 0;
            for (var _i = 0, _a = cursor.fetch(); _i < _a.length; _i++) {
                var doc = _a[_i];
                changes.push(this._addAt(doc, index++));
            }
            this.emit(changes);
            return null;
        }
        var hCurObserver = this._startCursorObserver(cursor);
        return new CursorHandle(hCurObserver);
    };
    MongoCursorObserver.prototype._startCursorObserver = function (cursor) {
        var _this = this;
        var changes = [];
        var callEmit = function () {
            _this.emit(changes.slice());
            changes.length = 0;
        };
        // Since cursor changes are now applied in bulk
        // (due to emit debouncing), scheduling macro task
        // allows us to use MeteorApp.onStable,
        // i.e. to know when the app is stable.
        var scheduleEmit = function () {
            return _this._ngZone.scheduleMacroTask('emit', callEmit, null, noop);
        };
        var init = false;
        var runTask = function (task) {
            task.invoke();
            _this._ngZone.run(noop);
            init = true;
        };
        var emit = null;
        if (this._debounceMs) {
            emit = debounce(function (task) { return runTask(task); }, this._debounceMs, scheduleEmit);
        }
        else {
            var initAdd_1 = debounce(function (task) { return runTask(task); }, 0, scheduleEmit);
            emit = function () {
                // This is for the case when cursor.observe
                // is called multiple times in a row
                // when the initial docs are being added.
                if (!init) {
                    initAdd_1();
                    return;
                }
                runTask(scheduleEmit());
            };
        }
        return gZone.run(function () { return cursor.observe({
            addedAt: function (doc, index) {
                var change = _this._addAt(doc, index);
                changes.push(change);
                emit();
            },
            changedAt: function (nDoc, oDoc, index) {
                var change = _this._updateAt(nDoc, index);
                changes.push(change);
                emit();
            },
            movedTo: function (doc, fromIndex, toIndex) {
                var change = _this._moveTo(doc, fromIndex, toIndex);
                changes.push(change);
                emit();
            },
            removedAt: function (doc, atIndex) {
                var change = _this._removeAt(atIndex);
                changes.push(change);
                emit();
            }
        }); });
    };
    MongoCursorObserver.prototype._updateAt = function (doc, index) {
        return new UpdateChange(index, doc);
    };
    MongoCursorObserver.prototype._addAt = function (doc, index) {
        var change = new AddChange(index, doc);
        return change;
    };
    MongoCursorObserver.prototype._moveTo = function (doc, fromIndex, toIndex) {
        return new MoveChange(fromIndex, toIndex);
    };
    MongoCursorObserver.prototype._removeAt = function (index) {
        return new RemoveChange(index);
    };
    return MongoCursorObserver;
}(_angular_core.EventEmitter));

function checkIfMongoCursor(cursor) {
    return MongoCursorObserver.isCursor(cursor);
}
// Creates an MongoCursorObserver instance for a Mongo.Cursor instance.
// Add one more level of abstraction, but currently is not really needed.
var MongoCursorObserverFactory = (function () {
    function MongoCursorObserverFactory() {
    }
    MongoCursorObserverFactory.prototype.create = function (cursor) {
        if (checkIfMongoCursor(cursor)) {
            return new MongoCursorObserver(cursor);
        }
        return null;
    };
    return MongoCursorObserverFactory;
}());
// An instance of this factory (see providers.ts) is registered globally
// as one of the providers of collection differs.
// These providers are being checked by an ngFor instance to find out which
// differ it needs to create and use for the current collection.
var MongoCursorDifferFactory = (function () {
    function MongoCursorDifferFactory() {
    }
    MongoCursorDifferFactory.prototype.supports = function (obj) { return checkIfMongoCursor(obj); };
    MongoCursorDifferFactory.prototype.create = function (cdRef) {
        return new MongoCursorDiffer(cdRef, new MongoCursorObserverFactory());
    };
    return MongoCursorDifferFactory;
}());
var trackById = function (index, item) { return item._id; };
/**
 * A class that implements Angular 2's concept of differs for ngFor.
 * API consists mainly of diff method and methods like forEachAddedItem
 * that is being run on each change detection cycle to apply new changes if any.
 */
var MongoCursorDiffer = (function (_super) {
    __extends(MongoCursorDiffer, _super);
    function MongoCursorDiffer(cdRef, obsFactory) {
        _super.call(this, trackById);
        this._inserted = [];
        this._removed = [];
        this._moved = [];
        this._updated = [];
        this._changes = [];
        this._forSize = 0;
        this._obsFactory = obsFactory;
    }
    MongoCursorDiffer.prototype.forEachAddedItem = function (fn) {
        for (var _i = 0, _a = this._inserted; _i < _a.length; _i++) {
            var insert = _a[_i];
            fn(insert);
        }
    };
    MongoCursorDiffer.prototype.forEachMovedItem = function (fn) {
        for (var _i = 0, _a = this._moved; _i < _a.length; _i++) {
            var move = _a[_i];
            fn(move);
        }
    };
    MongoCursorDiffer.prototype.forEachRemovedItem = function (fn) {
        for (var _i = 0, _a = this._removed; _i < _a.length; _i++) {
            var remove = _a[_i];
            fn(remove);
        }
    };
    MongoCursorDiffer.prototype.forEachIdentityChange = function (fn) {
        for (var _i = 0, _a = this._updated; _i < _a.length; _i++) {
            var update = _a[_i];
            fn(update);
        }
    };
    MongoCursorDiffer.prototype.forEachOperation = function (fn) {
        for (var _i = 0, _a = this._changes; _i < _a.length; _i++) {
            var change = _a[_i];
            fn(change, change.previousIndex, change.currentIndex);
        }
    };
    MongoCursorDiffer.prototype.diff = function (cursor) {
        var _this = this;
        this._reset();
        var newCursor = false;
        if (cursor && this._cursor !== cursor) {
            newCursor = true;
            this._destroyObserver();
            this._cursor = cursor;
            this._curObserver = this._obsFactory.create(cursor);
            this._sub = this._curObserver.subscribe({
                next: function (changes) { return _this._updateLatestValue(changes); }
            });
        }
        if (this._lastChanges) {
            this._applyChanges(this._lastChanges);
        }
        /**
         * If either last changes or new cursor is true, then
         * return "this" to notify Angular2 to re-build views.
         * If last changes or new cursor are true simultaneously
         * means that Mongo cursor has been changed and it's expected
         * that last changes (if any) of that cursor are additions only
         * (otherwise it won't likely work).
         * So removals of the previous cursor and additions of
         * the new one will processed at the same time.
         */
        if (this._lastChanges || newCursor) {
            this._lastChanges = null;
            return this;
        }
        return null;
    };
    MongoCursorDiffer.prototype.onDestroy = function () {
        this._destroyObserver();
    };
    Object.defineProperty(MongoCursorDiffer.prototype, "observer", {
        get: function () {
            return this._curObserver;
        },
        enumerable: true,
        configurable: true
    });
    MongoCursorDiffer.prototype._destroyObserver = function () {
        if (this._curObserver) {
            this._curObserver.destroy();
        }
        if (this._sub) {
            this._sub.unsubscribe();
        }
        this._applyCleanup();
    };
    MongoCursorDiffer.prototype._updateLatestValue = function (changes) {
        this._lastChanges = changes;
    };
    MongoCursorDiffer.prototype._reset = function () {
        this._inserted.length = 0;
        this._moved.length = 0;
        this._removed.length = 0;
        this._updated.length = 0;
        this._changes.length = 0;
    };
    // Reset previous state of the differ by removing all currently shown documents.
    MongoCursorDiffer.prototype._applyCleanup = function () {
        for (var index = 0; index < this._forSize; index++) {
            var remove = this._createChangeRecord(null, 0, null);
            this._removed.push(remove);
            this._changes.push(remove);
        }
        this._forSize = 0;
    };
    MongoCursorDiffer.prototype._applyChanges = function (changes) {
        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
            var change = changes_1[_i];
            if (change instanceof AddChange) {
                var add = this._createChangeRecord(change.index, null, change.item);
                this._inserted.push(add);
                this._changes.push(add);
                this._forSize++;
            }
            if (change instanceof MoveChange) {
                var move = this._createChangeRecord(change.toIndex, change.fromIndex, change.item);
                this._moved.push(move);
                this._changes.push(move);
            }
            if (change instanceof RemoveChange) {
                var remove = this._createChangeRecord(null, change.index, change.item);
                this._removed.push(remove);
                this._changes.push(remove);
                this._forSize--;
            }
            if (change instanceof UpdateChange) {
                this._updated.push(this._createChangeRecord(change.index, null, change.item));
            }
        }
    };
    MongoCursorDiffer.prototype._createChangeRecord = function (currentIndex, prevIndex, item) {
        var record = new _angular_core.CollectionChangeRecord(item, trackById);
        record.currentIndex = currentIndex;
        record.previousIndex = prevIndex;
        return record;
    };
    return MongoCursorDiffer;
}(_angular_core.DefaultIterableDiffer));

/**
 * A basic class to extend @Component and @Pipe.
 * Contains wrappers over main Meteor methods
 * that does some maintenance work behind the scene:
 * - Destroys subscription handles
 *   when the component or pipe is destroyed by Angular 2.
 * - Debounces ngZone runs reducing number of
 *   change detection runs.
 */
var MeteorReactive = (function () {
    function MeteorReactive() {
        this._hAutoruns = [];
        this._hSubscribes = [];
        this._ngZone = g.Zone.current;
    }
    /**
     * Method has the same notation as Meteor.autorun
     * except the last parameter.
     * @param func Callback to be executed when
     *   current computation is invalidated.
     * @param autoBind Determine whether Angular 2 zone will run
     *   after the func call to initiate change detection.
     */
    MeteorReactive.prototype.autorun = function (func, autoBind) {
        if (autoBind === void 0) { autoBind = true; }
        var pargs = this._prepArgs([func, autoBind]).pargs;
        var hAutorun = Tracker.autorun(pargs[0]);
        this._hAutoruns.push(hAutorun);
        return hAutorun;
    };
    /**
     *  Method has the same notation as Meteor.subscribe:
     *    subscribe(name, [args1, args2], [callbacks], [autoBind])
     *  except the last autoBind param (see autorun above).
     */
    MeteorReactive.prototype.subscribe = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var pargs = this._prepArgs(args).pargs;
        if (!Meteor.subscribe) {
            throw new Error('Meteor.subscribe is not defined on the server side');
        }
        
        var hSubscribe = Meteor.subscribe.apply(Meteor, [name].concat(pargs));
        if (Meteor.isClient) {
            this._hSubscribes.push(hSubscribe);
        }
        
        if (Meteor.isServer) {
            var callback = pargs[pargs.length - 1];
            if (_.isFunction(callback)) {
                callback();
            }
            if (isCallbacksObject(callback)) {
                callback.onReady();
            }
        }
        return hSubscribe;
    };
    MeteorReactive.prototype.call = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var pargs = this._prepArgs(args).pargs;
        return Meteor.call.apply(Meteor, [name].concat(pargs));
    };
    MeteorReactive.prototype.ngOnDestroy = function () {
        for (var _i = 0, _a = this._hAutoruns; _i < _a.length; _i++) {
            var hAutorun = _a[_i];
            hAutorun.stop();
        }
        for (var _b = 0, _c = this._hSubscribes; _b < _c.length; _b++) {
            var hSubscribe = _c[_b];
            hSubscribe.stop();
        }
        this._hAutoruns = null;
        this._hSubscribes = null;
    };
    MeteorReactive.prototype._prepArgs = function (args) {
        var lastParam = args[args.length - 1];
        var penultParam = args[args.length - 2];
        var autoBind = true;
        if (_.isBoolean(lastParam) &&
            isMeteorCallbacks(penultParam)) {
            args.pop();
            autoBind = lastParam !== false;
        }
        lastParam = args[args.length - 1];
        if (isMeteorCallbacks(lastParam)) {
            args.pop();
        }
        else {
            lastParam = noop;
        }
        // If autoBind is set to false then
        // we run user's callback in the global zone
        // instead of the current Angular 2 zone.
        var zone = autoBind ? this._ngZone : gZone;
        lastParam = wrapCallbackInZone(zone, lastParam, this);
        args.push(lastParam);
        return { pargs: args, autoBind: autoBind };
    };
    return MeteorReactive;
}());
// For the versions compatibility.
/* tslint:disable */
var MeteorComponent = MeteorReactive;

var DefaultIterableDifferFactory = (function () {
    function DefaultIterableDifferFactory() {
    }
    DefaultIterableDifferFactory.prototype.supports = function (obj) { return isListLikeIterable(obj); };
    DefaultIterableDifferFactory.prototype.create = function (cdRef, trackByFn) {
        return new _angular_core.DefaultIterableDiffer(trackByFn);
    };
    return DefaultIterableDifferFactory;
}());
function meteorProviders() {
    return [
        {
            provide: _angular_core.IterableDiffers,
            useFactory: function () { return new _angular_core.IterableDiffers([
                new DefaultIterableDifferFactory(),
                new MongoCursorDifferFactory()
            ]); }
        }
    ];
}
var METEOR_PROVIDERS = meteorProviders();

/// <reference types="zone.js" />
/// <reference types="meteor-typings" />
/// <reference types="@types/underscore" />

exports.ZoneRunScheduler = ZoneRunScheduler;
exports.zoneRunScheduler = zoneRunScheduler;
exports.wrapCallbackInZone = wrapCallbackInZone;
exports.scheduleMicroTask = scheduleMicroTask;
exports.AddChange = AddChange;
exports.UpdateChange = UpdateChange;
exports.MoveChange = MoveChange;
exports.RemoveChange = RemoveChange;
exports.MongoCursorObserver = MongoCursorObserver;
exports.MongoCursorDifferFactory = MongoCursorDifferFactory;
exports.MongoCursorDiffer = MongoCursorDiffer;
exports.MeteorReactive = MeteorReactive;
exports.MeteorComponent = MeteorComponent;
exports.DefaultIterableDifferFactory = DefaultIterableDifferFactory;
exports.METEOR_PROVIDERS = METEOR_PROVIDERS;

Object.defineProperty(exports, '__esModule', { value: true });

})));
